# Data Model: IMSS Medical Web Application

**Generated**: 2025-11-29
**Purpose**: Canonical data model for Phase 1 design and Phase 2 implementation. Includes entities, attributes, relationships, recommended Postgres types, indexes, constraints, and security notes (CURP handling, encryption).

## Overview

Primary entities:
- `users` (patients)
- `doctors`
- `appointments`
- `urgency_assessments`
- `doctor_schedules`
- `medicine_requests`
- `sick_leave_requests`

All tables include audit fields: `created_at TIMESTAMP WITH TIME ZONE DEFAULT now()`, `updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()` (update via trigger or application layer).

Sensitive fields (CURP) must be encrypted at rest and masked in logs. See Security Notes below.

## ER Diagram (simplified)

```
[users] 1---* [appointments] *---1 [doctors]
         |
         *
         [urgency_assessments]

[doctors] 1---* [doctor_schedules]

[appointments] 1---* [medicine_requests]
[appointments] 1---* [sick_leave_requests]
```

## Table Definitions (recommended Postgres schema snippets)

NOTE: Use a migration tool (Knex/TypeORM/Sequelize) to apply these schemas. Types below use Postgres conventions.

### users

- Primary identifier: `id UUID PRIMARY KEY` (generated by DB or app)
- CURP: store encrypted (see Security Notes), also keep a unique indexed value for lookup (e.g., `curp_hash`)

Example:

```sql
CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email TEXT NOT NULL UNIQUE,
  password_hash TEXT NOT NULL,
  curp_encrypted BYTEA NOT NULL,
  curp_hash TEXT NOT NULL UNIQUE, -- deterministic hash for lookup (HMAC using server-side key)
  full_name TEXT NOT NULL,
  phone TEXT,
  preferred_doctor_id UUID NULL REFERENCES doctors(id),
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

CREATE INDEX idx_users_email ON users (email);
CREATE INDEX idx_users_curp_hash ON users (curp_hash);
```

Rationale: Store CURP encrypted (AES-256) and maintain a deterministic HMAC (server key) in `curp_hash` for uniqueness/lookup without storing plain CURP.

### doctors

```sql
CREATE TABLE doctors (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  specialty TEXT NOT NULL,
  qualifications JSONB, -- array of qualification records
  years_experience INT,
  available_hours JSONB, -- store weekly availability slots
  current_patient_load INT DEFAULT 0,
  average_rating NUMERIC(3,2) DEFAULT 0.0,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

CREATE INDEX idx_doctors_specialty ON doctors (specialty);
```

### doctor_schedules

One record per doctor per date containing available_slots/booked_slots representation. Keep this denormalized for fast slot lookup and Redis cache sync.

```sql
CREATE TABLE doctor_schedules (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  doctor_id UUID NOT NULL REFERENCES doctors(id) ON DELETE CASCADE,
  date DATE NOT NULL,
  available_slots JSONB NOT NULL,
  booked_slots JSONB NOT NULL DEFAULT '[]'::jsonb,
  max_capacity INT DEFAULT 0,
  updated_at timestamptz DEFAULT now()
);

CREATE UNIQUE INDEX ux_doctor_schedule_date ON doctor_schedules (doctor_id, date);
CREATE INDEX idx_doctor_schedule_date ON doctor_schedules (date);
```

Notes: Keep `available_slots` as array of ISO-8601 times or slot objects {start, end, slot_id}. Use Redis to cache per-key `slots:{doctor_id}:{date}`.

### appointments

```sql
CREATE TYPE appointment_status AS ENUM ('BOOKED', 'COMPLETED', 'CANCELLED');
CREATE TYPE urgency_level AS ENUM ('LOW', 'MID', 'HIGH', 'EMERGENCY');

CREATE TABLE appointments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  doctor_id UUID NOT NULL REFERENCES doctors(id) ON DELETE SET NULL,
  scheduled_at timestamptz NOT NULL,
  urgency_level urgency_level NOT NULL DEFAULT 'LOW',
  reason TEXT,
  status appointment_status NOT NULL DEFAULT 'BOOKED',
  reference_number TEXT NOT NULL UNIQUE, -- human friendly reference
  clinical_notes TEXT,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

CREATE INDEX idx_appointments_user ON appointments (user_id);
CREATE INDEX idx_appointments_doctor_scheduled ON appointments (doctor_id, scheduled_at);
CREATE INDEX idx_appointments_status ON appointments (status);
```

Recommendation: Use `reference_number` generated by `APPT-YYYYMMDD-XXXX` pattern and unique constraint.

### urgency_assessments

Stores the five-question answers and computed score.

```sql
CREATE TABLE urgency_assessments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  appointment_id UUID NOT NULL REFERENCES appointments(id) ON DELETE CASCADE,
  question_responses JSONB NOT NULL, -- e.g. [{q:1,a:0},{q:2,a:2}]
  score INT NOT NULL,
  calculated_urgency urgency_level NOT NULL,
  emergency_flag BOOLEAN DEFAULT FALSE,
  created_at timestamptz DEFAULT now()
);

CREATE INDEX idx_urgency_appointment ON urgency_assessments (appointment_id);
```

### medicine_requests

```sql
CREATE TABLE medicine_requests (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  appointment_id UUID NULL REFERENCES appointments(id) ON DELETE SET NULL,
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  doctor_id UUID NULL REFERENCES doctors(id),
  medication_name TEXT NOT NULL,
  dosage TEXT,
  reason TEXT,
  status TEXT NOT NULL DEFAULT 'PENDING', -- consider ENUM
  doctor_notes TEXT,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

CREATE INDEX idx_medicine_requests_user ON medicine_requests (user_id);
```

### sick_leave_requests

```sql
CREATE TABLE sick_leave_requests (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  doctor_id UUID NULL REFERENCES doctors(id),
  reason TEXT,
  start_date DATE NOT NULL,
  end_date DATE NOT NULL,
  status TEXT NOT NULL DEFAULT 'PENDING', -- consider ENUM
  certificate_path TEXT NULL,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

CREATE INDEX idx_sick_leave_user ON sick_leave_requests (user_id);
```

## Indexing & Performance Notes

- Indexes:
  - `appointments(doctor_id, scheduled_at)` for efficient slot conflict checks and doctor availability queries
  - `doctor_schedules(doctor_id, date)` unique index to maintain single schedule record per day
  - `users(curp_hash)` for deterministic CURP lookups
- Partitioning:
  - Consider partitioning `appointments` by date (monthly) if volume is high
- Caching:
  - Use Redis keys `slots:{doctor_id}:{date}` mirroring `doctor_schedules.available_slots`
  - Cache invalidation: write-through and publish/subscribe notifications on booking/cancellation

## Constraints & Validation

- CURP validation: server-side regex + deterministic `curp_hash` computed with HMAC-SHA256 using a server secret
- `reference_number` generated atomically to avoid collisions
- Prevent double-booking: transactional booking flow that: 1) checks `doctor_schedules` available_slots and `appointments` for scheduled time; 2) writes appointment and updates schedule; 3) updates Redis cache
- Use DB transactions and optimistic locking (`version` column or `updated_at` checks) when updating `doctor_schedules`

## Security & Privacy Notes

- CURP should never be logged in full. Store `curp_encrypted` in DB (AES-256) and `curp_hash` (HMAC) for lookups. Use key management (KMS) to rotate encryption keys.
- Logs: mask CURP before writing to logs (e.g., `ABCDEF**********`). Use a centralized logger with structured JSON; do not log `password_hash` or `curp_encrypted`.
- Access controls: only authorized staff roles may access `clinical_notes` and sensitive records; enforce Row-Level Security (RLS) if required by policy.
- Audit trail: record `created_by`, `updated_by`, and an audit table for critical actions (appointment changes, emergency escalations).

## Implementation Guidance

- Use migrations to evolve schema; include rollback steps for each migration
- Add seeders to create initial `doctors` and `doctor_schedules` for development/testing
- Use ORMs (TypeORM/Knex) with explicit SQL for performance-critical queries (slot lookups, bulk exports)
- Ensure all date/time columns use `timestamptz` and store times in UTC; format to `es-MX` in frontend

## Open Questions / TODOs for Design Review

- Do we need Row-Level Security (RLS) enforcement for production due to IMSS policies? If yes, add to Phase 1 design.
- Confirm retention policy (appointments 7 years, audit logs 1 year) with legal/privacy SME and reflect in DB archival plan.
- Decide on `status` enumerations for medicine and sick leave requests (replace `TEXT` with `ENUM`).

---

**Artifacts produced**: `specs/001-imss-medical-app/data-model.md` (this file) â€” ready for review and to drive database migrations (T009).

